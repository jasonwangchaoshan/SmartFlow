//==============================================================================
//    S E N S I R I O N   AG,  Laubisruetistr. 50, CH-8712 Staefa, Switzerland
//==============================================================================
// Project   :  SF05 Sample Code (V1.0)
// File      :  sf05.c (V1.0)
// Author    :  RFU
// Date      :  07-Nov-2012
// Controller:  STM32F100RB
// IDE       :  Vision V4.60.0.0
// Compiler  :  Armcc
// Brief     :  Sensor Layer: Implementation of functions for sensor access.
//==============================================================================

//-- Includes ------------------------------------------------------------------
#include "sf05.h"
#include <string.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "SDP31.h"
#include "oled1306.h"
#include "ssd1366.h"
#include "PensaGpio.h"
#include "uart_echo.h"
//uint8_t readData[9]={0,0,0,0,0,0,0,0,0};
//#include "i2c_hal.h"
//-- Defines -------------------------------------------------------------------
// Offset and scale factors from datasheet (SFM3000).
#define OFFSET_FLOW 32000.0F   // offset flow
#define OFFSET_TEMP 20000.0F   // offset temperature
#define SCALE_FLOW    140.0F   // scale factor flow
#define SCALE_TEMP    100.0F   // scale factor temperature

#define ESP_SLAVE_ADDR                     0x28             /*!< ESP32 slave address, you can set any 7bit value */
#define WRITE_BIT                          I2C_MASTER_WRITE /*!< I2C master write */
#define READ_BIT                           I2C_MASTER_READ  /*!< I2C master read */
#define ACK_CHECK_EN                       0x1              /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS                      0x0              /*!< I2C master will not check ack from slave */
#define ACK_VAL                            0x0              /*!< I2C ack value */
#define NACK_VAL                           0x1              /*!< I2C nack value */
//-- Global Variables ----------------------------------------------------------
u16t currentCommand = 0x0000;
#define SDA_SDP31_PIN GPIO_NUM_18
#define SCL_SDP31_PIN GPIO_NUM_5

//==============================================================================
void SF05_Init(void){
//==============================================================================
 // I2c_Init(); // init I2C
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_SDP31_PIN,
		.scl_io_num = SCL_SDP31_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 100000
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, 0, 0, 0);
}
uint8_t crc8(const uint8_t data, uint8_t crc) {
  crc ^= data;

  for ( uint8_t i = 8; i; --i ) {
    crc = ( crc & 0x80 )
      ? (crc << 1) ^ 0x31
      : (crc << 1);
  }
  return crc;
}
float SF05_GetFlow2(void)
{

  u8t     checksum[1]; // checksum byte
  uint8_t     data[3];  // read data array
  int offset = 32000; // Offset for the sensor
  float scale = 140.0; // Scale factor for Air and N2 is 140.0, O2 is 142.8
  float Flow=0;
  int a=0;
  uint8_t mycrc = 0xFF; // initialize crc variable
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	espRc =i2c_master_write_byte(cmd, (I2C_ADR << 1) | I2C_MASTER_WRITE, true);//写地址


	i2c_master_write_byte(cmd, (FLOW_MEASUREMENT >> 8) & 0x00FF, true);//写命令
	i2c_master_write_byte(cmd, FLOW_MEASUREMENT & 0x00FF, true);

  	i2c_master_stop(cmd);
   	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_RATE_MS);
   	i2c_cmd_link_delete(cmd);

    	vTaskDelay(20 / portTICK_RATE_MS);

    	cmd = i2c_cmd_link_create();
     	i2c_master_start(cmd);

     	espRc = i2c_master_write_byte(cmd, (I2C_ADR << 1) |I2C_MASTER_READ, true);//写地址

	espRc=i2c_master_read(cmd, data, (uint8_t)3, ACK_VAL);//读数据
	i2c_master_stop(cmd);
	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

//	printf("data[0]: %d\n", data[0]);
//	printf("data[1]: %d\n", data[1]);
  
	  mycrc = crc8(data[0], mycrc); // let first byte through CRC calculation
 //	  printf("mycrc=%d",mycrc);
	  mycrc = crc8(data[1], mycrc); // and the second byte too
 //	  printf("mycrc=%d",mycrc);
  if (mycrc != data[2]) { // check if the calculated and the received CRC byte matches

   // return 0; 
  }
  else
  {
  //  a =(((data[0])<<8)|data[1]);
   // printf("a: %d", a);
   // Flow = (float)(((float)(a - offset)) / scale);
   // return Flow; 
  }
    a =(((data[0])<<8)|data[1]);
//    printf("a: %d", a);
    Flow = (float)(((float)(a - offset)) / scale);
//    printf("Flow: %10.3f", Flow);
    return Flow; 
}


void task_sf05_contrast(void *ignore) {

  etError  error;       // error code
  ft       flow;        // measured flow value
  ft       temperature; // measured temperature
  u16t     status;      // sensor status
  u16t     id;          // sensor id

  float flow2=0;
 // SF05_Init();
  char buf3[50];//用于打印数据
	/*float temp=0;
	float flow=0;float pressure;
	float FlowAll=0;
	char buf1[50];//用于打印数据
	char buf2[50];//用于打印数据
	char buf3[50];//用于打印数据*/
     while(1)
	{
       flow2=0;
       error = NO_ERROR;

	flow2=SF05_GetFlow2();

	printf("SF05_GetFlow2: %10.3f\n", flow2);
        sprintf(buf3," Flow2:%05.2f    ",flow2); //OLED显示
        oled_display(OLED_1_ADDRESS,5,buf3);  //OLED显示
        vTaskDelay(100 / portTICK_RATE_MS);
/*	
	//printf("getPressureDiff: %f\n", pressure);
	//printf("FlowAll: %f\n", FlowAll);
	//sprintf(buf3,"FlowAll:%-03.2f",4.3*FlowAll); //OLED显示
	printf("getPressureDiff: %03.2f\n", pressure);
	uart_my_printf(buf3,strlen(buf3));
	oled_display(OLED_1_ADDRESS,1,buf1);  //OLED显示
	oled_display(OLED_1_ADDRESS,2,buf2);  //OLED显示
	//oled_display(OLED_1_ADDRESS,3,buf3);  //OLED显示
        vTaskDelay(10 / portTICK_RATE_MS);*/
	}
}

void SF05_APP(void)
{

	xTaskCreate(&task_sf05_contrast, "task_sf05_contrast", 2048, NULL, 6, NULL);

}

